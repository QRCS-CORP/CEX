// The GPL version 3 License (GPLv3)
// 
// Copyright (c) 2023 QSCS.ca
// This file is part of the CEX Cryptographic library.
// 
// This program is free software : you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
//
// 
// Implementation Details:
// CSX512: An implementation of the ChaCha stream cipher
// Written by John G. Underhill, September 20, 2018
// Updated December 20, 2018
// Updated December 26, 2018
// Updated February 24, 2019
// Updated July 31, 2020
// Updated August 19, 2020
// Contact: develop@qscs.ca

#ifndef CEX_CSX512_H
#define CEX_CSX512_H

#include "IStreamCipher.h"
#include "ShakeModes.h"

NAMESPACE_STREAM

using Enumeration::ShakeModes;

/// <summary>
/// An [EXPERIMENTAL] parallelized and vectorized 64-bit 40-round stream cipher [CSX512] implementation based on ChaCha.
/// <para>This cipher uses an optional authentication mode; KMAC-512 enabled through the constructor to authenticate the stream.</para>
/// </summary>
/// 
/// <example>
/// <description>Encrypt and add a MAC code to an array:</description>
/// <code>
/// SymmetricKey kp(Key, Nonce);
/// CSX512 cipher(true);
/// // initialize for encryption
/// cipher.Initialize(true, kp);
/// cipher.Transform(Input, InOffset, Output, OutOffset, Length);
/// </code>
///
/// <description>Decrypt and authenticate an array:</description>
/// <code>
/// SymmetricKey kp(Key, Nonce);
/// CSX512 cipher(true);
/// // initialize for decryption
/// cipher.Initialize(false, kp);
/// // decrypt the ciphertext, if the authentication fails an exception is thrown
/// try
/// {
///		cipher.Transform(Input, InOffset, Output, OutOffset, Length);
/// }
/// catch (CryptoAuthenticationFailure)
/// {
///		// do something...
/// }
/// </code>
/// </example>
/// 
/// <remarks>
/// <description><B>Overview:</B></description>
/// <para>The CSX-512 stream cipher generates a key-stream by encrypting successive values of an incrementing 64-bit unsigned integer counter array. \n
/// The key-stream is then XOR'd with the input message block to create the cipher-text output. \n
/// In parallel mode, the counter is increased by a number factored from the number of input blocks, allowing for a multi-threaded operation. \n
/// The implementation is further parallelized by constructing a larger 'staggered' counter array, and processing large blocks using 256 or 512-bit AVX2/AVX512 instructions.</para>
/// 
/// <description><B>Description:</B></description>
/// <para><EM>Legend:</EM> \n 
/// <B>C</B>=ciphertext, <B>P</B>=plaintext, <B>K</B>=key, <B>E</B>=encrypt, <B>^</B>=XOR \n
/// <EM>Encryption</EM> \n
/// C0 ← IV. For 1 ≤ j ≤ t, Cj ← EK(Cj) ^ Pj, C+1.</para> \n
///
/// <description><B>Multi-Threading:</B></description>
/// <para>The transformation function used by CSX-512 is not limited by a dependency chain; this mode can be both SIMD pipelined and multi-threaded. \n
/// This is achieved by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads. \n 
/// The key stream generated by encrypting the counter array(s), is used as a source of random, and XOR'd with the message input to produce the cipher text.</para>
///
/// <description>Implementation Notes:</description>
/// <list type="bullet">
/// <item><description>The key size is fixed at 64 bytes (512-bits).</description></item>
/// <item><description>The nonce size is fixed at 16 bytes (128-bits).</description></item>
/// <item><description>The internal block size is 128 bytes (1024-bits) wide.</description></item>
/// <item><description>Permutation rounds are fixed at a default 40, but can be changed to 80 rounds by unremming the CEX_CSX512_STRONG in the CexConfig.h file.</description></item>
/// <item><description>The ISymmetricKey info value can be used as a cipher tweak to create a unique ciphertext and MAC output.</description></item>
/// <item><description>The ciphers Initialize function can use either a SymmetricKey container, or an encrypted SymmetricSecureKey.</description></item>
/// <item><description>This cipher is capable of authentication by setting the constructors Authenticate parameter to true, enabling KMAC-512 authentication.</description></item>
/// <item><description>In authentication mode, during encryption the MAC code is automatically appended to the output cipher-text after each transform call, during decryption, this MAC code is checked and authentication failure will generate a CryptoAuthenticationFailure exception.</description></item>
/// <item><description>If authentication is enabled, the cipher-key and MAC seed are generated using cSHAKE, this will change the cipher-text output.</description></item>
/// <item><description>The Info string is optional, but can be used to create a tweakable cipher; must be no longer than 48 bytes in length.</description></item>

/// <item><description>The class functions are virtual, and can be accessed from an IStreamCipher instance.</description></item>
/// <item><description>The transformation methods can not be called until the Initialize(ISymmetricKey) function has been called.</description></item>
/// <item><description>Encryption can both be pipelined (AVX, AVX2, or AVX512), and multi-threaded with any even number of threads, the configuration can be modified using the ParallelProfile() accessor function.</description></item>
/// <item><description>If the system supports Parallel processing, and ParallelProfile().IsParallel() is set to true; passing an input block of ParallelProfile().ParallelBlockSize() to the transform will be auto parallelized.</description></item>
/// <item><description>The ParallelProfile().ParallelThreadsMax() property is used as the thread count in the parallel loop; it defaults to the maximum number of available virtual cores, but is user-assignable, and must be an even number no greater than the number of processer cores on the system.</description></item>
/// <item><description>ParallelProfile().ParallelBlockSize() is calculated automatically based on processor(s) cache size but can be user defined, but must be evenly divisible by ParallelProfile().ParallelMinimumSize().</description></item>
/// <item><description>The ParallelBlockSize(), IsParallel(), and ParallelThreadsMax() accessors, can be changed through the ParallelProfile() property, the initial size is calculated automatically based on the systems capabilities, and modifying this vale is not recommended</description></item>
/// </list>
/// 
/// <description>Guiding Publications:</description>
/// <list type="number">
/// <item><description>ChaCha <a href="http://cr.yp.to/chacha/chacha-20080128.pdf">Specification</a>.</description></item>
/// <item><description>Fips-202: The <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">SHA-3 Standard</a></description>.</item>
/// <item><description>SP800-185: <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf">SHA-3 Derived Functions</a></description></item>
/// <item><description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">SHA3 Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition>.</description></item>
/// <item><description>FIPS 202: <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">Permutation Based Hash</a> and Extendable Output Functions</description></item>
/// <item><description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf">SP800-185</a> SHA-3 Derived Functions.</description></item>
/// <item><description>Team Keccak <a href="https://keccak.team/index.html">Homepage</a>.</description></item>
/// </list>
/// </remarks>
class CSX512 final : public IStreamCipher
{
private:

	static const size_t BLOCK_SIZE = 128;
	static const std::string CLASS_NAME;
	static const size_t IK512_SIZE = 64;
	static const size_t INFO_SIZE = 48;
	static const size_t NONCE_SIZE = 2;
#if defined(CEX_CSX512_STRONG)
	static const size_t ROUND_COUNT = 80;
#else
	static const size_t ROUND_COUNT = 40;
#endif
	static const std::vector<uint8_t> SIGMA_INFO;
	static const size_t STATE_PRECACHED = 2048;
	static const size_t STATE_THRESHOLD = 243;
	static const size_t STATE_SIZE = 14;
	static const size_t TAG_SIZE = 64;

	class CSX512State;
	std::unique_ptr<CSX512State> m_csx512State;
	std::unique_ptr<IMac> m_macAuthenticator;
	ParallelOptions m_parallelProfile;

public:

	//~~~Constructor~~~//

	/// <summary>
	/// Copy constructor: copy is restricted, this function has been deleted
	/// </summary>
	CSX512(const CSX512&) = delete;

	/// <summary>
	/// Copy operator: copy is restricted, this function has been deleted
	/// </summary>
	CSX512& operator=(const CSX512&) = delete;

	/// <summary>
	/// Initialize the ChaCha-512 cipher.
	/// <para>Setting the optional AuthenticatorType parameter to any value other than None, enables authentication for this cipher.
	/// Use the Finalize function to derive the Mac code once processing of the message stream has completed.
	/// The default authenticator parameter in ChaCha-512 is KMAC512; valid options are, None, HMACSHA2256, HMACSHA2512, KMAC256, and KMAC512.</para>
	/// </summary>
	///
	/// 
	/// <param name="Authenticate">Activate the authentication option</param>
	///
	/// <exception cref="CryptoSymmetricException">Thrown if an invalid authentication type is chosen</exception>
	explicit CSX512(bool Authenticate);

	/// <summary>
	/// Initialize the stream cipher using a secure-vector serialized state.
	/// <para>The Serialize function stores the internal state of the cipher, so that it can be reinitialized,
	/// without the need to call the Initialize function and key-schedule. 
	/// If this constructor is used, the cipher is fully initialized to the values it had when the Serialize function was called.</para>
	/// </summary>
	///
	/// <param name="State">The serialized state, created by the Serialize() function</param>
	///
	/// <exception cref="CryptoSymmetricException">Thrown if an invalid state array is used</exception>
	explicit CSX512(SecureVector<uint8_t> &State);

	/// <summary>
	/// Destructor: finalize this class
	/// </summary>
	~CSX512() override;

	//~~~Accessors~~~//

	/// <summary>
	/// Read Only: The stream ciphers enumeration type name
	/// </summary>
	const StreamCiphers Enumeral() override;

	/// <summary>
	/// Read Only: The cipher has authentication enabled
	/// </summary>
	const bool IsAuthenticator() override;

	/// <summary>
	/// Read Only: The cipher has been initialized for encryption
	/// </summary>
	const bool IsEncryption() override;

	/// <summary>
	/// Read Only: The cipher is ready to transform data
	/// </summary>
	const bool IsInitialized() override;

	/// <summary>
	/// Read Only: Processor parallelization availability.
	/// <para>Indicates whether parallel processing is available with this cipher.
	/// If parallel capable, input/output data arrays passed to the transform must be ParallelBlockSize in bytes to trigger parallel processing.</para>
	/// </summary>
	const bool IsParallel() override;

	/// <summary>
	/// Read Only: A vector of SymmetricKeySize containers, containing legal cipher input-key sizes
	/// </summary>
	const std::vector<SymmetricKeySize> &LegalKeySizes() override;

	/// <summary>
	/// Read Only: The stream ciphers formal implementation name
	/// </summary>
	const std::string Name() override;

	/// <summary>
	/// Read Only: The current value of the nonce counter array.
	/// </summary>
	const std::vector<uint8_t> Nonce() override;

	/// <summary>
	/// Read Only: Parallel block size; the uint8_t-size of the input/output data arrays passed to a transform that trigger parallel processing.
	/// <para>This value can be changed through the ParallelProfile class, but must be a multiple of the ParallelMinimumSize().</para>
	/// </summary>
	const size_t ParallelBlockSize() override;

	/// <summary>
	/// Read/Write: Parallel and SIMD capability flags and recommended sizes.
	/// <para>The maximum number of threads allocated when using multi-threaded processing can be set with the ParallelMaxDegree() property.
	/// The ParallelBlockSize() property is auto-calculated, but can be changed; the value must be evenly divisible by ParallelMinimumSize().
	/// Changes to these values must be made before the Initialize(bool, ISymmetricKey) function is called.</para>
	/// </summary>
	ParallelOptions &ParallelProfile() override;

	/// <summary>
	/// Read Only: The current standard-vector MAC tag value
	/// </summary>
	const std::vector<uint8_t> Tag() override;

	/// <summary>
	/// Copies the internal MAC tag to a secure-vector
	/// </summary>
	/// 
	/// <param name="Output">The secure-vector receiving the MAC code</param>
	const void Tag(SecureVector<uint8_t> &Output) override;

	/// <summary>
	/// Read Only: The legal MAC tag length in bytes
	/// </summary>
	const size_t TagSize() override;

	//~~~Public Functions~~~//

	/// <summary>
	/// Initialize the cipher with an ISymmetricKey key container.
	/// <para>If authentication is enabled, setting the Encryption parameter to false will decrypt and authenticate a ciphertext stream.
	/// Authentication on a decrypted stream is performed automatically; failure will throw a CryptoAuthenticationFailure exception.
	/// If encryption and authentication are set to true, the MAC code is appended to the cipher-text array after each transform call.</para>
	/// </summary>
	/// 
	/// <param name="Encryption">Using Encryption or Decryption mode</param>
	/// <param name="Parameters">Cipher key structure, containing cipher key, nonce, and optional info array</param>
	///
	/// <exception cref="CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
	void Initialize(bool Encryption, ISymmetricKey &Parameters) override;

	/// <summary>
	/// Set the maximum number of threads allocated when using multi-threaded processing.
	/// <para>When set to zero, thread count is set automatically. If set to 1, sets IsParallel() to false and runs in sequential mode. 
	/// Thread count must be an even number, and not exceed the number of processor virtual cores.</para>
	/// </summary>
	///
	/// <param name="Degree">The number of threads to allocate</param>
	/// 
	/// <exception cref="CryptoCipherModeException">Thrown if the degree parameter is invalid</exception>
	void ParallelMaxDegree(size_t Degree) override;

	/// <summary>
	/// Saves the internal state of the cipher to a secure vector.
	/// <para>The Serialize function can store the internal state of the cipher at the time it is invoked.
	/// The cipher instance can be reinitialized through a constructor option, without the need to re-call the Initialize function and associated key-schedule functions.
	/// This is useful in situations where the cipher is required intermitantly, and the entire state can be stored rather than just the key and nonce.</para>
	/// </summary>
	///
	/// <returns>The serialized cipher state</returns>
	SecureVector<uint8_t> Serialize();

	/// <summary>
	/// Add additional data to the message authentication code generator.  
	/// <para>Must be called after Initialize(bool, ISymmetricKey), and can then be called before or after a stream segment has been processed.</para>
	/// </summary>
	/// 
	/// <param name="Input">The input vector of bytes to process</param>
	/// <param name="Offset">The starting offset within the input vector</param>
	/// <param name="Length">The number of bytes to process</param>
	///
	/// <exception cref="CryptoSymmetricException">Thrown if the cipher is not initialized</exception>
	void SetAssociatedData(const std::vector<uint8_t> &Input, size_t Offset, size_t Length) override;

	/// <summary>
	/// Encrypt/Decrypt a vector of bytes with offset and length parameters.
	/// <para>Initialize(bool, ISymmetricKey) must be called before this method can be used.
	///	In authenticated encryption mode, the MAC code is automatically appended to the output stream at the end of the cipher-text, the output array must be int64_t enough to accommodate this TagSize() code.
	/// In decryption mode, this code is checked before the stream is decrypted, if the authentication fails a CryptoAuthenticationFailure exception is thrown.</para>
	/// </summary>
	/// 
	/// <param name="Input">The input vector of bytes to transform</param>
	/// <param name="InOffset">The starting offset within the input array</param>
	/// <param name="Output">The output vector of transformed bytes</param>
	/// <param name="OutOffset">The starting offset within the output vector</param>
	/// <param name="Length">The number of bytes to process</param>
	///
	/// <exception cref="CryptoAuthenticationFailure">Thrown during decryption if the the ciphertext fails authentication</exception>
	void Transform(const std::vector<uint8_t> &Input, size_t InOffset, std::vector<uint8_t> &Output, size_t OutOffset, size_t Length) override;

private:

	static void Finalize(std::unique_ptr<CSX512State> &State, std::unique_ptr<IMac> &Authenticator);
	static void Generate(std::unique_ptr<CSX512State> &State, std::vector<uint8_t> &Output, size_t OutOffset, std::array<uint64_t, 2> &Counter, size_t Length);
	void Load(const SecureVector<uint8_t> &Key, const SecureVector<uint8_t> &Nonce, const SecureVector<uint8_t> &Code);
	void Process(const std::vector<uint8_t> &Input, size_t InOffset, std::vector<uint8_t> &Output, size_t OutOffset, size_t Length);
	void Reset();
};

NAMESPACE_STREAMEND
#endif

